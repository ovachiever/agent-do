#!/usr/bin/env bash
# agent-debug - Debugger control

set -euo pipefail

show_help() {
    cat << 'EOF'
agent-debug - Debugger control

Commands:
  python <script>            Debug Python script with pdb
  node <script>              Debug Node.js script
  lldb <binary>              Debug binary with lldb
  gdb <binary>               Debug binary with gdb

  attach <pid>               Attach to running process
  core <binary> <core>       Debug core dump

  snapshot                   Debug environment as JSON (debuggable processes, tools available)
  processes [filter]         List debuggable processes

Python pdb commands (when attached):
  break <file:line>          Set breakpoint
  continue                   Continue execution
  step                       Step into
  next                       Step over
  print <expr>               Print expression
  list                       List source
  quit                       Quit debugger

Examples:
  agent-debug python app.py
  agent-debug node server.js
  agent-debug attach 12345
  agent-debug lldb ./myapp
EOF
}

cmd_python() {
    local script="${1:-}"
    shift || true

    if [[ -z "$script" ]]; then
        echo "Error: Script path required"
        return 1
    fi

    if [[ ! -f "$script" ]]; then
        echo "Error: Script not found: $script"
        return 1
    fi

    python3 -m pdb "$script" "$@"
}

cmd_node() {
    local script="${1:-}"
    shift || true

    if [[ -z "$script" ]]; then
        echo "Error: Script path required"
        return 1
    fi

    if [[ ! -f "$script" ]]; then
        echo "Error: Script not found: $script"
        return 1
    fi

    node inspect "$script" "$@"
}

cmd_lldb() {
    local binary="${1:-}"
    shift || true

    if [[ -z "$binary" ]]; then
        echo "Error: Binary path required"
        return 1
    fi

    if ! command -v lldb &> /dev/null; then
        echo "Error: lldb not found"
        return 1
    fi

    lldb "$binary" "$@"
}

cmd_gdb() {
    local binary="${1:-}"
    shift || true

    if [[ -z "$binary" ]]; then
        echo "Error: Binary path required"
        return 1
    fi

    if ! command -v gdb &> /dev/null; then
        echo "Error: gdb not found"
        echo "On macOS, use lldb instead: agent-debug lldb"
        return 1
    fi

    gdb "$binary" "$@"
}

cmd_attach() {
    local pid="${1:-}"

    if [[ -z "$pid" ]]; then
        echo "Error: PID required"
        return 1
    fi

    # Detect process type
    local proc_name
    proc_name=$(ps -p "$pid" -o comm= 2>/dev/null)

    if [[ -z "$proc_name" ]]; then
        echo "Error: Process $pid not found"
        return 1
    fi

    case "$proc_name" in
        *python*)
            echo "Attaching to Python process $pid..."
            echo "Note: Process must have been started with: python -m debugpy --listen 5678"
            if command -v python3 &> /dev/null; then
                python3 -c "
import debugpy
debugpy.connect(('localhost', 5678))
print('Connected to debugpy')
"
            fi
            ;;
        *node*)
            echo "Attaching to Node.js process $pid..."
            echo "Send SIGUSR1 to enable debugging: kill -USR1 $pid"
            kill -USR1 "$pid" 2>/dev/null || true
            sleep 1
            node inspect -p "$pid"
            ;;
        *)
            # Use lldb or gdb
            if command -v lldb &> /dev/null; then
                lldb -p "$pid"
            elif command -v gdb &> /dev/null; then
                gdb -p "$pid"
            else
                echo "Error: No debugger found for process type: $proc_name"
                return 1
            fi
            ;;
    esac
}

cmd_core() {
    local binary="${1:-}"
    local core="${2:-}"

    if [[ -z "$binary" ]] || [[ -z "$core" ]]; then
        echo "Error: Binary and core file required"
        echo "Usage: agent-debug core <binary> <core-file>"
        return 1
    fi

    if command -v lldb &> /dev/null; then
        lldb "$binary" -c "$core"
    elif command -v gdb &> /dev/null; then
        gdb "$binary" "$core"
    else
        echo "Error: No debugger (lldb/gdb) found"
        return 1
    fi
}

cmd_strace() {
    local pid="${1:-}"

    if [[ -z "$pid" ]]; then
        echo "Error: PID required"
        return 1
    fi

    if [[ "$(uname)" == "Darwin" ]]; then
        # Use dtruss on macOS (requires sudo)
        sudo dtruss -p "$pid"
    else
        if command -v strace &> /dev/null; then
            strace -p "$pid"
        else
            echo "Error: strace not found"
            return 1
        fi
    fi
}

cmd_snapshot() {
    python3 -c "
import subprocess, json, shutil, os

def run(cmd):
    r = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=5)
    return r.stdout.strip()

# Available debuggers
tools = {}
for tool in ['lldb', 'gdb', 'python3', 'node', 'strace', 'dtruss', 'dtrace']:
    path = shutil.which(tool)
    tools[tool] = {'available': path is not None, 'path': path or ''}

# Check python debug modules
for mod in ['pdb', 'debugpy', 'ipdb']:
    try:
        __import__(mod)
        tools[f'python:{mod}'] = {'available': True}
    except ImportError:
        tools[f'python:{mod}'] = {'available': False}

# Find debuggable processes (python, node, java)
processes = []
try:
    ps_out = run('ps -eo pid,comm,args')
    for line in ps_out.split('\n')[1:]:
        parts = line.split(None, 2)
        if len(parts) < 2:
            continue
        pid, comm = parts[0], parts[1]
        args = parts[2] if len(parts) > 2 else ''
        debuggable = False
        ptype = ''
        if 'python' in comm.lower():
            debuggable = True
            ptype = 'python'
        elif 'node' in comm.lower():
            debuggable = True
            ptype = 'node'
        elif 'java' in comm.lower():
            debuggable = True
            ptype = 'java'
        if debuggable:
            processes.append({
                'pid': int(pid),
                'type': ptype,
                'command': args[:100],
            })
except:
    pass

# Core dumps
cores = []
for path in ['/cores', '/var/crash', os.path.expanduser('~')]:
    if os.path.isdir(path):
        for f in os.listdir(path):
            if f.startswith('core') or f.endswith('.core') or f.endswith('.crash'):
                cores.append(os.path.join(path, f))

snapshot = {
    'tools': {k: v for k, v in tools.items() if v.get('available')},
    'missing_tools': {k: v for k, v in tools.items() if not v.get('available')},
    'debuggable_processes': {'count': len(processes), 'items': processes[:20]},
    'core_dumps': cores[:10],
    'platform': run('uname -s'),
}
print(json.dumps(snapshot, indent=2))
"
}

cmd_processes() {
    local filter="${1:-}"
    python3 - "$filter" << 'PYEOF'
import subprocess, sys
ps = subprocess.run(['ps', '-eo', 'pid,comm,args'], capture_output=True, text=True).stdout
filt = sys.argv[1].lower() if len(sys.argv) > 1 else ''
print(f'{"PID":>7}  {"TYPE":8}  COMMAND')
print('-' * 60)
for line in ps.strip().split('\n')[1:]:
    parts = line.split(None, 2)
    if len(parts) < 2: continue
    pid, comm = parts[0], parts[1]
    args = parts[2] if len(parts) > 2 else ''
    ptype = ''
    if 'python' in comm.lower(): ptype = 'python'
    elif 'node' in comm.lower(): ptype = 'node'
    elif 'java' in comm.lower(): ptype = 'java'
    elif 'ruby' in comm.lower(): ptype = 'ruby'
    if ptype and (not filt or filt in ptype or filt in args.lower()):
        print(f'{pid:>7}  {ptype:8}  {args[:70]}')
PYEOF
}

# Main
case "${1:-help}" in
    python|py|pdb)
        shift
        cmd_python "$@"
        ;;
    node|js)
        shift
        cmd_node "$@"
        ;;
    lldb)
        shift
        cmd_lldb "$@"
        ;;
    gdb)
        shift
        cmd_gdb "$@"
        ;;
    attach)
        shift
        cmd_attach "$@"
        ;;
    core)
        shift
        cmd_core "$@"
        ;;
    strace|trace)
        shift
        cmd_strace "$@"
        ;;
    snapshot|snap)
        cmd_snapshot
        ;;
    processes|procs|ps)
        shift || true
        cmd_processes "$@"
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        # If it looks like a script, try to debug it
        if [[ -f "$1" ]]; then
            case "$1" in
                *.py) cmd_python "$@" ;;
                *.js) cmd_node "$@" ;;
                *) cmd_lldb "$@" ;;
            esac
        else
            echo "Unknown command: $1"
            echo "Try: agent-debug help"
            exit 1
        fi
        ;;
esac
