#!/usr/bin/env bash
# agent-agent - Control AI coding agent sessions (Claude, OpenCode, Droid, Amp)
# Wrapper around agent-tui specialized for AI agents

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TUI="$SCRIPT_DIR/agent-tui"
PREFIX="agent-agent-"

# Agent configurations: command, ready_pattern, busy_pattern
declare -A AGENT_CMD=(
    [claude]="claude"
    [opencode]="opencode"
    [droid]="droid"
    [amp]="amp"
)

declare -A AGENT_READY_PATTERN=(
    [claude]="\? for shortcuts"
    [opencode]="\? for shortcuts|awaiting"
    [droid]="\? for shortcuts"
    [amp]="\? for shortcuts|awaiting"
)

declare -A AGENT_BUSY_PATTERN=(
    [claude]="⠋|⠙|⠹|⠸|⠼|⠴|⠦|⠧|⠇|⠏|Thinking|Working|Creating|Swooping|Reading|Searching|thinking|esc to interrupt"
    [opencode]="⠋|⠙|⠹|⠸|⠼|⠴|⠦|⠧|⠇|⠏|thinking|working|processing"
    [droid]="⠋|⠙|⠹|⠸|⠼|⠴|⠦|⠧|⠇|⠏|Thinking|Working|Creating|Swooping|Reading|Searching"
    [amp]="⠋|⠙|⠹|⠸|⠼|⠴|⠦|⠧|⠇|⠏|thinking|working|processing"
)

DEFAULT_TIMEOUT=300000  # 5 minutes for agent responses
POLL_INTERVAL=500

die() { echo "error: $1" >&2; exit "${2:-1}"; }

show_help() {
    cat << 'EOF'
agent-agent - AI coding agent control

SPAWN
  spawn <type>                   Start an agent (claude, opencode, droid, amp)
  spawn <type> --session <name>  Named session
  spawn <type> --dir <path>      Working directory
  spawn <type> --wait            Wait until agent is ready before returning
  spawn <type> --headless        Use non-interactive mode (Claude: -p flag)

SESSION MANAGEMENT
  list                           List active agent sessions
  kill [--session <name>]        Kill agent session
  attach [--session <name>]      Get tmux attach command

INTERACTION
  send <prompt> [--session <n>]  Send prompt and wait for response
  send <prompt> --nowait         Send without waiting
  snapshot [--session <name>]    Get current screen
  snapshot --strip               Strip ANSI color codes (clean text)
  snapshot --scroll              Include scrollback history (1000 lines)
  status [--session <name>]      Check if agent is ready/busy
  extract [--session <name>]     Extract code blocks from last response
  extract --all                  Get all code blocks as JSON
  extract --lang <lang>          Filter by language (python, bash, etc.)
  extract --scroll               Include scrollback history
  wait [--session <name>]        Wait until agent becomes ready
  wait --timeout <ms>            Custom timeout (default: 5 minutes)

SPECIAL COMMANDS
  accept [--session <name>]      Accept pending changes (press 'y')
  reject [--session <name>]      Reject pending changes (press 'n')
  cancel [--session <name>]      Cancel current operation (Ctrl+C)
  escape [--session <name>]      Press Escape (exit mode/menu)

EXAMPLES
  # Start Claude in current project
  agent-agent spawn claude --dir ~/myproject

  # Send a task
  agent-agent send "fix the login bug in auth.py"

  # Check if it's done
  agent-agent status

  # Get the output
  agent-agent snapshot

  # Accept changes
  agent-agent accept

  # Clean up
  agent-agent kill

AGENT TYPES
  claude     Claude Code CLI (Anthropic)
  opencode   OpenCode CLI
  droid      Factory Droid CLI
  amp        Amp CLI

NOTES
  - TUI capture works with proper TERM settings (xterm-256color)
  - Use 'attach' command to interact directly with the live TUI
  - Use snapshot --lines for debugging screen positions
  - Session names are stored with 'agent-agent-' prefix in tmux

EOF
}

# Resolve session (convert user-facing name to tmux session name)
resolve_session() {
    local user_session="${1:-}"
    if [[ -n "$user_session" ]]; then
        echo "${PREFIX}${user_session}"
        return
    fi
    # Find single active session
    local sessions
    sessions=$(tmux list-sessions -F '#{session_name}' 2>/dev/null | grep "^${PREFIX}" || true)
    local count=0
    if [[ -n "$sessions" ]]; then
        count=$(echo "$sessions" | wc -l | tr -d ' ')
    fi
    if [[ "$count" -eq 0 ]]; then
        die "No agent sessions found. Run 'agent-agent spawn <type>' first."
    elif [[ "$count" -eq 1 ]]; then
        echo "$sessions"
    else
        die "Multiple sessions active. Specify with --session. Run 'agent-agent list' to see them."
    fi
}

# Get user-facing session name from tmux session name
user_session_name() {
    echo "${1#$PREFIX}"
}

# Check if session exists
session_exists() {
    tmux has-session -t "$1" 2>/dev/null
}

# Get snapshot via agent-tui
get_snapshot() {
    local tmux_session="$1"
    local user_session
    user_session=$(user_session_name "$tmux_session")
    "$TUI" snapshot --session "${user_session#agent-tui-}"
}

# Detect agent type from session metadata or screen content
detect_agent_type() {
    local tmux_session="$1"
    # Check session environment variable we set during spawn
    local agent_type
    agent_type=$(tmux show-environment -t "$tmux_session" AGENT_TYPE 2>/dev/null | cut -d= -f2 || true)
    if [[ -n "$agent_type" ]]; then
        echo "$agent_type"
        return
    fi
    # Fallback: guess from screen content
    echo "claude"  # Default
}

cmd_spawn() {
    local agent_type="" user_session="" workdir="" wait_ready=false
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --session) user_session="$2"; shift 2 ;;
            --dir) workdir="$2"; shift 2 ;;
            --wait) wait_ready=true; shift ;;
            *)
                if [[ -z "$agent_type" ]]; then
                    agent_type="$1"; shift
                else
                    die "unexpected argument: $1"
                fi
                ;;
        esac
    done

    [[ -n "$agent_type" ]] || die "usage: agent-agent spawn <type> [--session <name>] [--dir <path>] [--wait]"

    # Validate agent type
    if [[ -z "${AGENT_CMD[$agent_type]:-}" ]]; then
        die "unknown agent type: $agent_type. Supported: claude, opencode, droid, amp"
    fi

    # Generate session name if not provided
    if [[ -z "$user_session" ]]; then
        user_session="${agent_type}-$(date +%s)"
    fi

    local tmux_session="${PREFIX}${user_session}"
    local tui_session="${user_session}"

    if session_exists "$tmux_session"; then
        die "session '$user_session' already exists"
    fi

    # Build command
    local cmd="${AGENT_CMD[$agent_type]}"

    # Create tmux session - use default TERM (xterm-256color) for full TUI support
    # Claude and other agents need proper terminal capabilities
    local width=200 height=60
    
    if [[ -n "$workdir" ]]; then
        tmux new-session -d -s "$tmux_session" -x "$width" -y "$height" -c "$workdir" "$cmd"
    else
        tmux new-session -d -s "$tmux_session" -x "$width" -y "$height" "$cmd"
    fi

    # Store agent type in session environment
    tmux set-environment -t "$tmux_session" AGENT_TYPE "$agent_type"

    # Wait for agent to be ready if requested
    if $wait_ready; then
        local timeout=60000  # 60 seconds for startup
        local elapsed=0
        local poll_sec=0.5
        
        echo -n "Waiting for $agent_type to start..." >&2
        while [[ $elapsed -lt $timeout ]]; do
            local content
            content=$(tmux capture-pane -t "$tmux_session" -p 2>/dev/null || true)
            if echo "$content" | grep -qE "${AGENT_READY_PATTERN[$agent_type]}"; then
                echo " ready" >&2
                echo "$user_session"
                return 0
            fi
            sleep "$poll_sec"
            elapsed=$((elapsed + 500))
            echo -n "." >&2
        done
        echo " timeout" >&2
        die "agent failed to start within 60 seconds"
    fi

    echo "$user_session"
}

cmd_list() {
    local sessions
    sessions=$(tmux list-sessions -F '#{session_name}' 2>/dev/null | grep "^${PREFIX}" || true)
    if [[ -z "$sessions" ]]; then
        echo "No agent sessions."
        return
    fi
    echo "Active agent sessions:"
    while IFS= read -r session; do
        local user_name
        user_name=$(user_session_name "$session")
        local agent_type
        agent_type=$(tmux show-environment -t "$session" AGENT_TYPE 2>/dev/null | cut -d= -f2 || echo "unknown")
        local status="unknown"
        # Quick status check
        local content
        content=$(tmux capture-pane -t "$session" -p 2>/dev/null || true)
        if echo "$content" | grep -qE "${AGENT_BUSY_PATTERN[$agent_type]:-⠋}"; then
            status="busy"
        elif echo "$content" | grep -qE "${AGENT_READY_PATTERN[$agent_type]:-^>}"; then
            status="ready"
        fi
        printf "  %-20s %-10s %s\n" "$user_name" "$agent_type" "($status)"
    done <<< "$sessions"
}

cmd_kill() {
    local user_session=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --session) user_session="$2"; shift 2 ;;
            *) die "unexpected argument: $1" ;;
        esac
    done

    local tmux_session
    tmux_session=$(resolve_session "$user_session")
    session_exists "$tmux_session" || die "session not found"

    tmux kill-session -t "$tmux_session"
    echo "Killed session: $(user_session_name "$tmux_session")"
}

cmd_attach() {
    local user_session=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --session) user_session="$2"; shift 2 ;;
            *) die "unexpected argument: $1" ;;
        esac
    done

    local tmux_session
    tmux_session=$(resolve_session "$user_session")
    session_exists "$tmux_session" || die "session not found"

    echo "tmux attach -t $tmux_session"
}

cmd_snapshot() {
    local user_session="" json=false lines=false strip=false scroll=false
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --session) user_session="$2"; shift 2 ;;
            --json) json=true; shift ;;
            --lines) lines=true; shift ;;
            --strip) strip=true; shift ;;
            --scroll) scroll=true; shift ;;
            *) die "unexpected argument: $1" ;;
        esac
    done

    local tmux_session
    tmux_session=$(resolve_session "$user_session")
    session_exists "$tmux_session" || die "session not found"

    # Capture options:
    # -e: include escape sequences (colors)
    # -J: preserve wrapped lines
    # -S -1000: include scrollback (1000 lines)
    local capture_opts="-p"
    if $scroll; then
        capture_opts="$capture_opts -S -1000"
    fi
    
    local content
    content=$(tmux capture-pane -t "$tmux_session" $capture_opts 2>/dev/null || tmux capture-pane -t "$tmux_session" -p)
    
    # Strip ANSI escape codes if requested
    if $strip; then
        content=$(echo "$content" | sed 's/\x1b\[[0-9;]*m//g')
    fi

    if $json; then
        local agent_type
        agent_type=$(detect_agent_type "$tmux_session")
        local width height
        width=$(tmux display -t "$tmux_session" -p '#{window_width}')
        height=$(tmux display -t "$tmux_session" -p '#{window_height}')

        python3 -c "
import json, sys
content = sys.stdin.read()
print(json.dumps({
    'session': '$(user_session_name "$tmux_session")',
    'agent_type': '$agent_type',
    'dimensions': {'width': $width, 'height': $height},
    'content': content
}, indent=2))
" <<< "$content"
    elif $lines; then
        local i=1
        while IFS= read -r line; do
            printf "%3d│ %s\n" "$i" "$line"
            ((i++))
        done <<< "$content"
    else
        echo "$content"
    fi
}

cmd_status() {
    local user_session="" json=false
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --session) user_session="$2"; shift 2 ;;
            --json) json=true; shift ;;
            *) die "unexpected argument: $1" ;;
        esac
    done

    local tmux_session
    tmux_session=$(resolve_session "$user_session")
    session_exists "$tmux_session" || die "session not found"

    local agent_type
    agent_type=$(detect_agent_type "$tmux_session")

    local content
    content=$(tmux capture-pane -t "$tmux_session" -p)

    local status="unknown"
    if echo "$content" | grep -qE "${AGENT_BUSY_PATTERN[$agent_type]:-⠋}"; then
        status="busy"
    elif echo "$content" | grep -qE "${AGENT_READY_PATTERN[$agent_type]:-^>}"; then
        status="ready"
    fi

    if $json; then
        echo "{\"session\":\"$(user_session_name "$tmux_session")\",\"agent_type\":\"$agent_type\",\"status\":\"$status\"}"
    else
        echo "$status"
    fi
}

cmd_send() {
    local user_session="" prompt="" nowait=false timeout=$DEFAULT_TIMEOUT
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --session) user_session="$2"; shift 2 ;;
            --nowait) nowait=true; shift ;;
            --timeout) timeout="$2"; shift 2 ;;
            *)
                if [[ -z "$prompt" ]]; then
                    prompt="$1"; shift
                else
                    die "unexpected argument: $1"
                fi
                ;;
        esac
    done

    [[ -n "$prompt" ]] || die "usage: agent-agent send <prompt> [--session <name>] [--nowait]"

    local tmux_session
    tmux_session=$(resolve_session "$user_session")
    session_exists "$tmux_session" || die "session not found"

    local agent_type
    agent_type=$(detect_agent_type "$tmux_session")

    # Type the prompt
    tmux send-keys -t "$tmux_session" -l -- "$prompt"
    # Press Enter
    tmux send-keys -t "$tmux_session" Enter

    if $nowait; then
        echo "Sent prompt (not waiting for response)"
        return 0
    fi

    # Wait for agent to start processing, then wait for it to finish
    local elapsed=0
    local poll_sec
    poll_sec=$(echo "scale=3; $POLL_INTERVAL / 1000" | bc)

    # First, wait a moment for the agent to start
    sleep 0.5

    # Now wait for agent to become ready again
    while [[ $elapsed -lt $timeout ]]; do
        local content
        content=$(tmux capture-pane -t "$tmux_session" -p)

        # Check if agent is ready (not busy)
        if ! echo "$content" | grep -qE "${AGENT_BUSY_PATTERN[$agent_type]:-⠋}"; then
            if echo "$content" | grep -qE "${AGENT_READY_PATTERN[$agent_type]:-^>}"; then
                echo "Response complete"
                return 0
            fi
        fi

        sleep "$poll_sec"
        elapsed=$((elapsed + POLL_INTERVAL))
    done

    die "timeout waiting for agent response" 2
}

cmd_accept() {
    local user_session=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --session) user_session="$2"; shift 2 ;;
            *) die "unexpected argument: $1" ;;
        esac
    done

    local tmux_session
    tmux_session=$(resolve_session "$user_session")
    session_exists "$tmux_session" || die "session not found"

    tmux send-keys -t "$tmux_session" "y"
    echo "Sent accept (y)"
}

cmd_reject() {
    local user_session=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --session) user_session="$2"; shift 2 ;;
            *) die "unexpected argument: $1" ;;
        esac
    done

    local tmux_session
    tmux_session=$(resolve_session "$user_session")
    session_exists "$tmux_session" || die "session not found"

    tmux send-keys -t "$tmux_session" "n"
    echo "Sent reject (n)"
}

cmd_cancel() {
    local user_session=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --session) user_session="$2"; shift 2 ;;
            *) die "unexpected argument: $1" ;;
        esac
    done

    local tmux_session
    tmux_session=$(resolve_session "$user_session")
    session_exists "$tmux_session" || die "session not found"

    tmux send-keys -t "$tmux_session" C-c
    echo "Sent cancel (Ctrl+C)"
}

cmd_escape() {
    local user_session=""
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --session) user_session="$2"; shift 2 ;;
            *) die "unexpected argument: $1" ;;
        esac
    done

    local tmux_session
    tmux_session=$(resolve_session "$user_session")
    session_exists "$tmux_session" || die "session not found"

    tmux send-keys -t "$tmux_session" Escape
    echo "Sent Escape"
}

cmd_wait() {
    local user_session="" timeout=$DEFAULT_TIMEOUT
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --session) user_session="$2"; shift 2 ;;
            --timeout) timeout="$2"; shift 2 ;;
            *) die "unexpected argument: $1" ;;
        esac
    done

    local tmux_session
    tmux_session=$(resolve_session "$user_session")
    session_exists "$tmux_session" || die "session not found"

    local agent_type
    agent_type=$(detect_agent_type "$tmux_session")

    local elapsed=0
    local poll_sec
    poll_sec=$(echo "scale=3; $POLL_INTERVAL / 1000" | bc)

    echo -n "Waiting for agent..." >&2
    while [[ $elapsed -lt $timeout ]]; do
        local content
        content=$(tmux capture-pane -t "$tmux_session" -p)

        # Check if agent is ready (not busy)
        if ! echo "$content" | grep -qE "${AGENT_BUSY_PATTERN[$agent_type]:-⠋}"; then
            if echo "$content" | grep -qE "${AGENT_READY_PATTERN[$agent_type]:-^>}"; then
                echo " ready" >&2
                echo "ready"
                return 0
            fi
        fi

        sleep "$poll_sec"
        elapsed=$((elapsed + POLL_INTERVAL))
        # Print dot every 2 seconds
        if [[ $((elapsed % 2000)) -eq 0 ]]; then
            echo -n "." >&2
        fi
    done

    echo " timeout" >&2
    die "timeout waiting for agent to become ready" 2
}

cmd_extract() {
    local user_session="" lang="" all=false scroll=false
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --session) user_session="$2"; shift 2 ;;
            --lang) lang="$2"; shift 2 ;;
            --all) all=true; shift ;;
            --scroll) scroll=true; shift ;;
            *) die "unexpected argument: $1" ;;
        esac
    done

    local tmux_session
    tmux_session=$(resolve_session "$user_session")
    session_exists "$tmux_session" || die "session not found"

    # Get screen content
    local capture_opts="-p"
    if $scroll; then
        capture_opts="$capture_opts -S -1000"
    fi
    
    local content
    content=$(tmux capture-pane -t "$tmux_session" $capture_opts 2>/dev/null || tmux capture-pane -t "$tmux_session" -p)
    # Strip ANSI codes for easier parsing
    content=$(echo "$content" | sed 's/\x1b\[[0-9;]*m//g')

    # Extract code blocks using Python for robust multiline regex
    python3 << 'PYEOF' - "$content" "$lang" "$all"
import sys
import re
import json

content = sys.argv[1]
filter_lang = sys.argv[2] if len(sys.argv) > 2 and sys.argv[2] else None
extract_all = sys.argv[3].lower() == 'true' if len(sys.argv) > 3 else False

# Pattern for fenced code blocks: ```language\ncode\n```
# Also handles ``` without language
pattern = r'```(\w*)\n(.*?)```'
matches = re.findall(pattern, content, re.DOTALL)

blocks = []
for lang, code in matches:
    lang = lang.strip() if lang else 'text'
    code = code.strip()
    if filter_lang and lang != filter_lang:
        continue
    blocks.append({'lang': lang, 'code': code})

if not blocks:
    print("No code blocks found", file=sys.stderr)
    sys.exit(0)

if extract_all:
    # Output all blocks as JSON
    print(json.dumps(blocks, indent=2))
else:
    # Output just the last code block (most recent response)
    last = blocks[-1]
    print(f"# Language: {last['lang']}")
    print(last['code'])
PYEOF
}

# Main
case "${1:-}" in
    spawn)    shift; cmd_spawn "$@" ;;
    list)     shift; cmd_list "$@" ;;
    kill)     shift; cmd_kill "$@" ;;
    attach)   shift; cmd_attach "$@" ;;
    snapshot) shift; cmd_snapshot "$@" ;;
    status)   shift; cmd_status "$@" ;;
    send)     shift; cmd_send "$@" ;;
    accept)   shift; cmd_accept "$@" ;;
    reject)   shift; cmd_reject "$@" ;;
    cancel)   shift; cmd_cancel "$@" ;;
    escape)   shift; cmd_escape "$@" ;;
    wait)     shift; cmd_wait "$@" ;;
    extract)  shift; cmd_extract "$@" ;;
    -h|--help|help|"") show_help ;;
    *)        die "unknown command: $1. Run 'agent-agent --help'." ;;
esac
