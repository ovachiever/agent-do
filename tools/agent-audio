#!/usr/bin/env bash
# agent-audio - Audio processing

set -euo pipefail

show_help() {
    cat << 'EOF'
agent-audio - Audio processing

Commands:
  info <file>                Show audio info
  convert <file> <format>    Convert format (mp3, wav, ogg, flac)
  trim <file> <start> <end>  Trim audio (HH:MM:SS format)
  merge <files...> <output>  Merge audio files
  volume <file> <level>      Adjust volume (e.g., 1.5, 0.5, +3dB)
  extract <video> [output]   Extract audio from video
  transcribe <file>          Transcribe audio (requires whisper)

Options:
  -o, --output <path>        Output file path

Requirements:
  - ffmpeg for most operations
  - whisper for transcription

Examples:
  agent-audio convert song.wav mp3
  agent-audio trim podcast.mp3 00:05:00 00:10:00
  agent-audio extract video.mp4 audio.mp3
  agent-audio transcribe recording.mp3
EOF
}

check_ffmpeg() {
    if ! command -v ffmpeg &> /dev/null; then
        echo "Error: ffmpeg not found"
        exit 1
    fi
}

cmd_info() {
    local file="${1:-}"

    if [[ -z "$file" ]] || [[ ! -f "$file" ]]; then
        echo "Error: Valid file required"
        return 1
    fi

    if command -v ffprobe &> /dev/null; then
        ffprobe -v quiet -show_format -show_streams "$file" 2>/dev/null | \
            grep -E "^(codec_name|channels|sample_rate|bit_rate|duration|format_name)=" | head -20
    else
        file "$file"
    fi
}

cmd_convert() {
    local file="${1:-}"
    local format="${2:-}"
    local output=""

    shift 2 || true
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -o|--output) output="$2"; shift 2 ;;
            *) shift ;;
        esac
    done

    if [[ -z "$file" ]] || [[ -z "$format" ]]; then
        echo "Error: File and format required"
        return 1
    fi

    check_ffmpeg

    format="${format#.}"
    [[ -z "$output" ]] && output="${file%.*}.$format"

    ffmpeg -i "$file" -y "$output" 2>/dev/null
    echo "Converted to $output"
}

cmd_trim() {
    local file="${1:-}"
    local start="${2:-}"
    local end="${3:-}"
    local output=""

    shift 3 || true
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -o|--output) output="$2"; shift 2 ;;
            *) shift ;;
        esac
    done

    if [[ -z "$file" ]] || [[ -z "$start" ]] || [[ -z "$end" ]]; then
        echo "Error: File, start time, and end time required"
        echo "Usage: agent-audio trim <file> <start> <end>"
        return 1
    fi

    check_ffmpeg

    [[ -z "$output" ]] && output="${file%.*}-trimmed.${file##*.}"

    ffmpeg -i "$file" -ss "$start" -to "$end" -y "$output" 2>/dev/null
    echo "Trimmed to $output"
}

cmd_merge() {
    local files=()
    local output=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -o|--output)
                output="$2"
                shift 2
                ;;
            *)
                if [[ $# -eq 1 ]] && [[ -z "$output" ]]; then
                    output="$1"
                else
                    files+=("$1")
                fi
                shift
                ;;
        esac
    done

    if [[ ${#files[@]} -lt 2 ]] || [[ -z "$output" ]]; then
        echo "Error: At least 2 input files and output required"
        return 1
    fi

    check_ffmpeg

    # Create concat file
    local concat_file="/tmp/audio-concat-$$.txt"
    for f in "${files[@]}"; do
        echo "file '$(realpath "$f")'" >> "$concat_file"
    done

    ffmpeg -f concat -safe 0 -i "$concat_file" -y "$output" 2>/dev/null
    rm -f "$concat_file"

    echo "Merged to $output"
}

cmd_volume() {
    local file="${1:-}"
    local level="${2:-}"
    local output=""

    shift 2 || true
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -o|--output) output="$2"; shift 2 ;;
            *) shift ;;
        esac
    done

    if [[ -z "$file" ]] || [[ -z "$level" ]]; then
        echo "Error: File and volume level required"
        return 1
    fi

    check_ffmpeg

    [[ -z "$output" ]] && output="${file%.*}-vol.${file##*.}"

    # Handle dB notation
    local filter="volume=$level"
    if [[ "$level" =~ dB$ ]]; then
        filter="volume=${level}"
    fi

    ffmpeg -i "$file" -af "$filter" -y "$output" 2>/dev/null
    echo "Volume adjusted: $output"
}

cmd_extract() {
    local video="${1:-}"
    local output="${2:-}"

    if [[ -z "$video" ]] || [[ ! -f "$video" ]]; then
        echo "Error: Valid video file required"
        return 1
    fi

    check_ffmpeg

    [[ -z "$output" ]] && output="${video%.*}.mp3"

    ffmpeg -i "$video" -vn -acodec libmp3lame -y "$output" 2>/dev/null
    echo "Extracted audio to $output"
}

cmd_transcribe() {
    local file="${1:-}"
    local model="${2:-base}"

    if [[ -z "$file" ]] || [[ ! -f "$file" ]]; then
        echo "Error: Valid audio file required"
        return 1
    fi

    if command -v whisper &> /dev/null; then
        whisper "$file" --model "$model" --output_format txt
    elif python3 -c "import whisper" 2>/dev/null; then
        python3 << PYTHON
import whisper
model = whisper.load_model("$model")
result = model.transcribe("$file")
print(result["text"])
PYTHON
    else
        echo "Error: whisper not found"
        echo "Install with: pip install openai-whisper"
        return 1
    fi
}

# Main
case "${1:-help}" in
    info|i)
        shift
        cmd_info "$@"
        ;;
    convert|c)
        shift
        cmd_convert "$@"
        ;;
    trim|cut)
        shift
        cmd_trim "$@"
        ;;
    merge|join|concat)
        shift
        cmd_merge "$@"
        ;;
    volume|vol)
        shift
        cmd_volume "$@"
        ;;
    extract|audio)
        shift
        cmd_extract "$@"
        ;;
    transcribe|speech|stt)
        shift
        cmd_transcribe "$@"
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        echo "Unknown command: $1"
        echo "Try: agent-audio help"
        exit 1
        ;;
esac
