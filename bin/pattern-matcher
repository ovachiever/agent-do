#!/usr/bin/env python3
"""
Offline pattern matcher for agent-do.
Provides fallback when LLM is unavailable.
"""

import sys
import re
from pathlib import Path
from typing import Optional

# Add lib to path
sys.path.insert(0, str(Path(__file__).parent.parent / "lib"))

from registry import load_registry, search_tools
from cache import fuzzy_match, get_all_patterns


# Common intent patterns
PATTERNS = [
    # TUI patterns
    (r'(?:start|spawn|run|open)\s+(\w+)', 'tui', 'spawn', lambda m: [m.group(1)]),
    (r'screenshot.*session\s*(\d+)', 'tui', 'snapshot', lambda m: [m.group(1)]),
    (r'send\s+[\'"]?(.+?)[\'"]?\s+to\s+(?:session\s*)?(\d+)', 'tui', 'send', lambda m: [m.group(2), m.group(1)]),

    # iOS patterns
    (r'(?:screenshot|capture).*(?:ios|iphone|ipad|simulator)', 'ios', 'screenshot', lambda m: []),
    (r'tap\s+(?:at\s+)?(\d+)[,\s]+(\d+)', 'ios', 'tap', lambda m: [m.group(1), m.group(2)]),
    (r'launch\s+(.+?)\s+(?:on\s+)?(?:ios|iphone|simulator)', 'ios', 'launch', lambda m: [m.group(1)]),

    # GUI patterns
    (r'click\s+(?:the\s+)?(.+?)\s+(?:button\s+)?(?:in\s+)?(\w+)', 'gui', 'click', lambda m: [m.group(2), '--title', m.group(1)]),
    (r'type\s+[\'"]?(.+?)[\'"]?\s+(?:in|into)\s+(.+)', 'gui', 'type', lambda m: ['--role', 'textfield', m.group(1)]),

    # Docker patterns
    (r'(?:show|list).*(?:running\s+)?containers', 'docker', 'ps', lambda m: []),
    (r'(?:view\s+)?logs?\s+(?:for\s+)?(\w+)', 'docker', 'logs', lambda m: [m.group(1)]),
    (r'(?:run\s+)?(?:bash|shell)\s+(?:in\s+)?(\w+)', 'docker', 'shell', lambda m: [m.group(1)]),

    # REPL patterns
    (r'(?:start|spawn)\s+(?:a\s+)?(\w+)\s+repl', 'repl', 'spawn', lambda m: [m.group(1)]),
    (r'send\s+[\'"]?(.+?)[\'"]?\s+to\s+(?:my\s+)?(\w+)(?:\s+session)?', 'repl', 'send', lambda m: ['1', m.group(1)]),

    # Network patterns
    (r'what[\'s]*\s+(?:is\s+)?using\s+port\s+(\d+)', 'network', 'scan', lambda m: ['--port', m.group(1)]),
    (r'ping\s+(\S+)', 'network', 'ping', lambda m: [m.group(1)]),

    # Git patterns
    (r'commit\s+(?:all\s+)?(?:changes)?', 'git', 'commit', lambda m: []),
    (r'show\s+(?:recent\s+)?commits', 'git', 'log', lambda m: []),

    # Slack patterns
    (r'(?:post|send)\s+[\'"]?(.+?)[\'"]?\s+to\s+([#@]\w+)', 'slack', 'send', lambda m: [m.group(2), m.group(1)]),

    # Clipboard patterns
    (r'copy\s+[\'"]?(.+?)[\'"]?\s+to\s+clipboard', 'clipboard', 'copy', lambda m: [m.group(1)]),

    # Screenshot/OCR patterns
    (r'extract\s+text\s+from\s+screen', 'ocr', 'screen', lambda m: []),
]


def match_patterns(intent: str) -> Optional[dict]:
    """Try to match intent against known patterns."""
    intent_lower = intent.lower()

    for pattern, tool, command, args_fn in PATTERNS:
        match = re.search(pattern, intent_lower, re.IGNORECASE)
        if match:
            return {
                'tool': tool,
                'command': command,
                'args': args_fn(match),
                'flags': {},
                'confidence': 0.7,
                'explanation': f"Matched pattern for {tool} {command}",
                'from_pattern': True
            }

    return None


def keyword_match(intent: str, registry: dict) -> Optional[dict]:
    """Try to match based on keywords in registry."""
    results = search_tools(registry, intent)

    if not results:
        return None

    tool, info = results[0]
    commands = list(info.get('commands', {}).keys())

    if not commands:
        return None

    # Try to guess the best command
    intent_lower = intent.lower()
    best_cmd = commands[0]

    for cmd in commands:
        if cmd.lower() in intent_lower:
            best_cmd = cmd
            break

    return {
        'tool': tool,
        'command': best_cmd,
        'args': [],
        'flags': {},
        'confidence': 0.5,
        'explanation': f"Keyword match for {tool} (may need clarification)",
        'clarification_needed': f"Did you want to use {tool} {best_cmd}? Please provide more details."
    }


def match_intent(intent: str) -> dict:
    """Try all matching strategies."""

    # 1. Try cache/fuzzy match
    fuzzy = fuzzy_match(intent)
    if fuzzy:
        fuzzy['from_fuzzy'] = True
        return fuzzy

    # 2. Try pattern matching
    pattern_match = match_patterns(intent)
    if pattern_match:
        return pattern_match

    # 3. Try keyword matching
    registry = load_registry()
    keyword = keyword_match(intent, registry)
    if keyword:
        return keyword

    # 4. No match
    return {
        'tool': None,
        'command': None,
        'args': [],
        'flags': {},
        'confidence': 0,
        'explanation': None,
        'clarification_needed': "Could not understand intent. Please rephrase or use 'agent-do --how' for help."
    }


def main():
    import argparse
    parser = argparse.ArgumentParser(description="Offline pattern matcher for agent-do")
    parser.add_argument("intent", nargs="*", help="Natural language intent")
    parser.add_argument("--json", action="store_true", help="Output JSON")
    args = parser.parse_args()

    intent = " ".join(args.intent)
    if not intent:
        print("Usage: pattern-matcher \"what you want to do\"")
        return 1

    result = match_intent(intent)

    if args.json:
        import json
        print(json.dumps(result, indent=2))
    else:
        if result.get('tool'):
            cmd = f"agent-{result['tool']} {result['command']}"
            if result.get('args'):
                cmd += ' ' + ' '.join(result['args'])
            print(f"Matched: {cmd}")
            if result.get('explanation'):
                print(f"  ({result['explanation']})")
        else:
            print(result.get('clarification_needed', 'No match found'))

    return 0 if result.get('tool') else 1


if __name__ == "__main__":
    sys.exit(main())
